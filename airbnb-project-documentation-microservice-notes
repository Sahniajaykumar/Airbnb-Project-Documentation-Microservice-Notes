Q: How do you convert AuthServce project(monolithic) into distributed microservice architecture ?
--------------------------------------------------------------------------------------------------------

Step 1 : For that add Eureka client(ensure that you already created Eureka Server) inside authservice to register this project with Eureka server

<dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${spring-cloud.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

Step 2 : Enable @EnableDiscoveryClient in main class of authservice class to register with Eureka server
--------------------------------------------------------------------------------------------------------------

Step 3 : Now put this in authservice propertise class for good practice 
---------------------------------------------------------------------------------------------------------------

#Eureka - Optional if you are running eureka on port 8671
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

---------------------------------------------------------------------------------------------------------------
Create API Gateway project for JWL Filterization : add routing  in YML file 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1. First remove JWTFilter class from configuration file and modify security filter chain because i am not filtering JWT in config file 
2. I will filter the jwt token in API Gateway class 
 // ====================================
 // 3. Security Filter Chain Configuration
 // ====================================
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> {
                auth.requestMatchers(OPEN_URLS).permitAll()
                    .anyRequest().permitAll(); // AuthService doesn‚Äôt validate JWT now
            });

        return http.build();
    }
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Step 1: Inject this JWT library dependency in pom.xml file 
--------------------------------------------------------------------
   <dependency>
		    <groupId>com.auth0</groupId>
		    <artifactId>java-jwt</artifactId>
		    <version>4.4.0</version> <!-- or the latest stable version -->
		</dependency>

Step 2 : Create JwtAuthenticationFilter class inside Gateway project for Token validation at Gateway : 
Use a Gateway GlobalFilter (or a custom GatewayFilterFactory) that runs before the request is routed.
In Spring Cloud Gateway (WebFlux) the filter will be reactive.

Created JwtAuthenticationFilter class : 
-----------------------------------------
package com.apigateway.filter;

import java.util.List;
import java.util.Map;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;

import reactor.core.publisher.Mono;

@Component // which ever URL will come with token first come to this class for verification
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {
	
	 private static final String SECRET_KEY = "my-super-secret-key"; // should match signature

	    private static final List<String> openApiEndpoints = List.of( // open URL
	            "/auth/api/v1/auth/login",
	            "/auth/api/v1/auth/register"
	    );

	    private static final Map<String, List<String>> protectedEndpointsWithRoles = Map.of(
	    	    "/auth/api/v1/welcome/message", List.of("ROLE_ADMIN") // protected URL/auth written from YML file
	    	);


	    @Override
	    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
	        String requestPath = exchange.getRequest().getURI().getPath();

	        // Allow public ENDPOINTS 
	        if (isPublicEndpoint(requestPath)) {
	            return chain.filter(exchange);
	        }

	        String authHeader = exchange.getRequest().getHeaders().getFirst("Authorization");
	        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        String token = authHeader.substring(7);

	        try {
	            DecodedJWT jwt = JWT.require(Algorithm.HMAC256(SECRET_KEY))
	                    .build()
	                    .verify(token);

	            String role = jwt.getClaim("role").asString();

	            System.out.println("Request path: " + requestPath);
	            System.out.println("Role from token: " + role);

	            if (!isAuthorized(requestPath, role)) {
	                exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
	                return exchange.getResponse().setComplete();
	            }

	            // Pass role to downstream services (optional)
	            exchange = exchange.mutate()
	                    .request(r -> r.header("X-User-Role", role))
	                    .build();

	        } catch (JWTVerificationException e) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        return chain.filter(exchange);
	    }

	    private boolean isPublicEndpoint(String path) {
	        return openApiEndpoints.stream().anyMatch(path::equalsIgnoreCase);
	    }

	    private boolean isAuthorized(String path, String role) {
	        for (Map.Entry<String, List<String>> entry : protectedEndpointsWithRoles.entrySet()) {
	            String protectedPath = entry.getKey();
	            List<String> allowedRoles = entry.getValue();

	            if (path.startsWith(protectedPath)) {
	                System.out.println("Matched protected path: " + protectedPath + " | Allowed roles: " + allowedRoles);
	                return allowedRoles.contains(role);
	            }
	        }
	        return true; // Allow access if path is not protected (can be changed to false to deny by default)
	    }

	    @Override
	    public int getOrder() {
	        return -1;
	    }
	}

Step 4: Add Routes in yml file 
-----------------------------------
server:
  port: 5555
  
spring:
  application:
    name: api-gateway-1

  cloud:
    gateway:
      routes:

        # Route for microservice-1
        - id: authservice-api-1
          uri: lb://AUTH-SERVICE
          predicates:
            - Path=/auth/**
          filters:
            - RewritePath=/auth/(?<segment>.*), /${segment}

        # Route for microservice-2 // this is for next microservice 
        - id: microservice-api-2
          uri: lb://MICROSERVICE-2
          predicates:
            - Path=/micro2/**
          filters:
            - RewritePath=/micro2/(?<segment>.*), /${segment}


Step 5 : Now perform registration and login operation :

(a) register :POST : http://localhost:5555/auth/api/v1/auth/register
 {
    "username":"amresh",
    "name":"amresh",
    "email":"amresh@gmail.com",
    "password":"Ajay@123"
}
_________________________________________________
{
    "message": "Registration Successful",
    "status": 201,
    "data": "User registered successfully"
}

(b) login : POST : http://localhost:5555/auth/api/v1/auth/login , you will get JWT token after copy and

past in authorization header to access protected URL : GET : http://localhost:8083/api/v1/welcome/message , you will get welcome ajay

Q: How do you secure a microservices project (very important)?
---------------------------------------------------------------

Step 1 : Create an AuthService using Spring Security and JWT Toekn.
--> AuthService handles user registration, login, and JWT token generation.

Step 2 : When a user logs in, AuthService validates credentials and generates a signed JWT token (with subject, roles, expiry, etc.)

Step 3 : On every request, the API Gateway verify the token (which is the common entry point) 
using JwtAuthenticationFilter which implements GlobalFilter in Spring Cloud Gateway.

step 4 : Inside the Filter method verify the token 

Step 5 : Backend microservices should also verify the token or trust signed user headers ‚Üí defense-in-depth security.

===============================================================================================================

Next Microservice-2 Project :

Step 1 : create Microservice-2 project using following these dependency : 

1. Spring Web
2. Spring Security
3. Eureka Discovery Client
4. OpenFeign Client
5. DevTools
6. <!-- Auth0 JWT -->
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>java-jwt</artifactId>
        <version>4.4.0</version>
    </dependency>

Step 2: Enable @EnableDiscoveryClient in main class of Microservice-2 project

Step 3 : After create WelcomeControllerApi for testing api inside controller pacage 

package com.microservice2.controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WelcomeControllerApi {
	
	@GetMapping("/message")
	public String getMessage() {
		return "welcome ajay bhai from microservice-2";
	}
}
Step 4 : Now go to ApI Gateway(auth-service(microservice-1)) and do the configuration for microservice-2 in YML file 

server:
  port: 5555
  
spring:
  application:
    name: api-gateway-1

  cloud:
    gateway:
      routes:

        # Route for microservice-1
        - id: authservice-api-1
          uri: lb://AUTH-SERVICE
          predicates:
            - Path=/auth/**
          filters:
            - RewritePath=/auth/(?<segment>.*), /${segment}

        # Route for microservice-2
        - id: microservice-api-2
          uri: lb://MICROSERVICE-2
          predicates:
            - Path=/micro2/**
          filters:
            - RewritePath=/micro2/(?<segment>.*), /${segment}

step 5 : change the port name in application.propertise file(microservice-2)

step 6 : now create AppSecurityConfig class(config pacage) and write this 

package com.microservice2.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.microservice2.filter.JwtFilter;

@Configuration
@EnableWebSecurity
public class AppSecurityConfig {
	
	 @Autowired
	    private JwtFilter jwtFilter;

	    String[] publicEndpoints = {
	        "/v3/api-docs/**",
	        "/swagger-ui/**",
	        "/swagger-ui.html",
	        "/swagger-resources/**",
	        "/webjars/**",
	        "/actuator/**", 
	        "/eureka/**"
	    };

	    @Bean
	    public PasswordEncoder getEncoder() {
	        return new BCryptPasswordEncoder();
	    }

	    @Bean
	    public SecurityFilterChain securityConfig(HttpSecurity http) throws Exception {

	        http.csrf(csrf -> csrf.disable())
	            .authorizeHttpRequests(req -> req
	                    .requestMatchers(publicEndpoints).permitAll()
	                    .anyRequest().authenticated()
	            )
	            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

	        return http.build();
	    }

}
Step 7 : now create a User DTO class (dto package) 

package com.microservice2.dto;

public class User {
	
	private long id;
	
	private String name;
	
	private String username;
	
    private String email;
	
	private String password;
	
	private String role;
	
	
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getRole() {
		return role;
	}

	public void setRole(String role) {
		this.role = role;
	}
}
Step 8 : Now create JwtFilter class and JwtService class(inside filter pacage) for filterization not for createing JWT token 
JwtFilter.class : 
-------------------
package com.microservice2.filter;

import java.io.IOException;
import java.util.Collections;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.microservice2.client.AuthServiceFeignClient;
import com.microservice2.dto.User;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class JwtFilter extends OncePerRequestFilter {
	
	 @Autowired
	    private JwtService jwtService;
	    
	    @Autowired
	    private AuthServiceFeignClient authServiceFeignClient;
	    

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {
		
		
		String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String jwt = authHeader.substring(7);
            String username = jwtService.validateTokenAndRetrieveSubject(jwt);

            User user = authServiceFeignClient.getUserByUsername(username,authHeader);
                   
            
                var authToken = new UsernamePasswordAuthenticationToken(
                		user, null, Collections.singleton(new SimpleGrantedAuthority(user.getRole())));

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
       
        filterChain.doFilter(request, response);
				
	}
}

JwtService.class for logic(like token validation not creating)
------------------------------
package com.microservice2.filter;

import org.springframework.stereotype.Service;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;

@Service
public class JwtService {
	
	private static final String SECRET_KEY = "my-super-secret-key";
   // private static final long EXPIRATION_TIME = 86400000; // 1 day

//    public String generateToken(String username, String role) {
//        return JWT.create()
//            .withSubject(username)
//            .withClaim("role", role)
//            .withIssuedAt(new Date())
//            .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
//            .sign(Algorithm.HMAC256(SECRET_KEY));
//    }

    public String validateTokenAndRetrieveSubject(String token) {
        return JWT.require(Algorithm.HMAC256(SECRET_KEY))
            .build()
            .verify(token)
            .getSubject();
    }
}

Step 8 : Now create AuthServiceFeignClient interface for microservice communication and enable FeignClient using @EnableFeignClients in Main class 

package com.microservice2.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;

import com.microservice2.dto.User;

@FeignClient(name = "AUTH-SERVICE")
public interface AuthServiceFeignClient {
	
	@GetMapping("/api/v1/auth/get-user") 
    User getUserByUsername(@RequestParam("username") String username, @RequestHeader("Authorization") String token);

}

Step 9 : Now go to Auth-service(microservice-1) and write this logic 

@GetMapping("/get-user")
	 public User getUserByUserName(@RequestParam String username) {
		 
		 User user = userRepository.findByUsername(username);
		 return user;		 
	 }


Step 10 : Now put the URL of microservice-2 in main gateway(api-gateway/JwtAuthenticationFilter) 

"/micro2/message", List.of("ROLE_ADMIN") --> only this so that only ROle_Admin can access this URL not Not Role_User
-------------------------------------------

package com.apigateway.filter;

import java.util.List;
import java.util.Map;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;

import reactor.core.publisher.Mono;

@Component // which ever URL will come with token first come to this class for verification
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {
	
	 private static final String SECRET_KEY = "my-super-secret-key"; // should match signature

	    private static final List<String> openApiEndpoints = List.of( // open URL
	            "/auth/api/v1/auth/login",
	            "/auth/api/v1/auth/register"
	    );

	    private static final Map<String, List<String>> protectedEndpointsWithRoles = Map.of(
	    	    //"/auth/api/v1/welcome/message", List.of("ROLE_ADMIN"), // protected URL/auth written from api-gateway-1 YML file
	    	    "/micro2/message", List.of("ROLE_ADMIN")   // modified            // protected URL/micro2 written from api-gateway-1 YML file
	    	);


	    @Override
	    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
	        String requestPath = exchange.getRequest().getURI().getPath();

	        // Allow public ENDPOINTS 
	        if (isPublicEndpoint(requestPath)) {
	            return chain.filter(exchange);
	        }

	        String authHeader = exchange.getRequest().getHeaders().getFirst("Authorization");
	        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        String token = authHeader.substring(7);

	        try {
	            DecodedJWT jwt = JWT.require(Algorithm.HMAC256(SECRET_KEY))
	                    .build()
	                    .verify(token);

	            String role = jwt.getClaim("role").asString();

	            System.out.println("Request path: " + requestPath);
	            System.out.println("Role from token: " + role);

	            if (!isAuthorized(requestPath, role)) {
	                exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
	                return exchange.getResponse().setComplete();
	            }

	            // Pass role to downstream services (optional)
	            exchange = exchange.mutate()
	                    .request(r -> r.header("X-User-Role", role))
	                    .build();

	        } catch (JWTVerificationException e) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        return chain.filter(exchange);
	    }

	    private boolean isPublicEndpoint(String path) {
	        return openApiEndpoints.stream().anyMatch(path::equalsIgnoreCase);
	    }

	    private boolean isAuthorized(String path, String role) {
	        for (Map.Entry<String, List<String>> entry : protectedEndpointsWithRoles.entrySet()) {
	            String protectedPath = entry.getKey();
	            List<String> allowedRoles = entry.getValue();

	            if (path.startsWith(protectedPath)) {
	                System.out.println("Matched protected path: " + protectedPath + " | Allowed roles: " + allowedRoles);
	                return allowedRoles.contains(role);
	            }
	        }
	        return true; // Allow access if path is not protected (can be changed to false to deny by default)
	    }

	    @Override
	    public int getOrder() {
	        return -1;
	    }
	}

Note : Follow the link for login and access the microservice protected URL : 

login as a admin : Post : http://localhost:5555/auth/api/v1/auth/login

access protected url GET : http://localhost:5555/micro2/message  // only Roles_Admin can access this url not Roles_User be aware 

======================================================================
Create a property-microservice-3 project using following dependency : 
======================================================================
1. spring web
2. MySQL driever 
3. spring data jpa
4. spring boot Devtolls

Step 1 : build Er diagram using entity class and perform mapping with each other.

Step 2 : perform configuration in application.propertise file
server.port = 9091
# ================================
# DATABASE CONFIGURATION
# ================================
spring.datasource.url=jdbc:mysql://localhost:3306/propertyservicedb
spring.datasource.username=root
spring.datasource.password=database-password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ================================
# JPA / HIBERNATE CONFIGURATION
# ================================
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect

Step 3 : create a entity pacage and inside entity package create following entity class and perform mapping by showing ER diagram

(a) . Create a Property Entity class .

package com.propertyMicroservice.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

@Entity
@Table(name="property")
public class Property {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;
	
	private String name;
	
	@Column(name="number_of_beds")
	private int numberOfBeds;
	
	@Column(name="number_of_rooms")
	private int numberOfRooms;
	
	@Column(name="number_of_bathrooms")
	private int numberOfBathrooms;
	
	@Column(name="number_of_guests_allowed")
	private int numberOfGuestAllowed;
	
	@ManyToOne // because property is many and City is one
	@JoinColumn(name = "city_id")  // declare joinColumn and give attribute name
	private City city; // taking references from City to
	
	@ManyToOne
	@JoinColumn(name="area_id")
	private Area area;
	
	@ManyToOne
	@JoinColumn(name="state_id")
	private State state;
	
	public City getCity() {
		return city;
	}
	
	public void setCity(City city) {
		this.city = city;
	}
	
	public Area getArea() {
		return area;
	}
	public void setArea(Area area) {
		this.area = area;
	}
	
	public State getState() {
		return state;
	}
	
	public void setState(State state) {
		this.state = state;
	}
	
	public long getId() {
		return id;
	}
	
	public void setId(long id) {
		this.id = id;
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	public int getNumberOfBeds() {
		return numberOfBeds;
	}
	
	public void setNumberOfBeds(int numberOfBeds) {
		this.numberOfBeds = numberOfBeds;
	}
	
	public int getNumberOfRooms() {
		return numberOfRooms;
	}
	
	public void setNumberOfRooms(int numberOfRooms) {
		this.numberOfRooms = numberOfRooms;
	}
	
	public int getNumberOfBathrooms() {
		return numberOfBathrooms;
	}
	
	public void setNumberOfBathrooms(int numberOfBathrooms) {
		this.numberOfBathrooms = numberOfBathrooms;
	}
	
	public int getNumberOfGuestAllowed() {
		return numberOfGuestAllowed;
	}
	
	public void setNumberOfGuestAllowed(int numberOfGuestAllowed) {
		this.numberOfGuestAllowed = numberOfGuestAllowed;
	}
}

(b). Create a propertyPhoto entity class 

package com.propertyMicroservice.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

@Entity
@Table(name="rooms")
public class Rooms {
	
	 @Id
	    @GeneratedValue(strategy = GenerationType.IDENTITY)
	    private long id;

	    private String roomType;

	    @Column(name = "base_price")
	    private double basePrice;

	    @ManyToOne // first part belongs to entity class and second part belongs to reference class
	    @JoinColumn(name = "property_id")
	    @JsonBackReference
	    private Property property;

		public long getId() {
			return id;
		}

		public String getRoomType() {
			return roomType;
		}

		public double getBasePrice() {
			return basePrice;
		}

		public Property getProperty() {
			return property;
		}

		public void setId(long id) {
			this.id = id;
		}

		public void setRoomType(String roomType) {
			this.roomType = roomType;
		}

		public void setBasePrice(double basePrice) {
			this.basePrice = basePrice;
		}

		public void setProperty(Property property) {
			this.property = property;
		}
}


(c). After Create City Entity class 
package com.propertyMicroservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="city")
public class City {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;
	
	private String name;
	
	public long getId() {
		return id;
	}
	
	public void setId(long id) {
		this.id = id;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
}

(d). Create a Area Entity class : 
package com.propertyMicroservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="area")
public class Area {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;
	
	private String name;
	
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

}
(e). Create state Entity class 
package com.propertyMicroservice.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="state")
public class State {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;
	private String name;
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

}
(f). Create a Rooms Entity class : 
package com.propertyMicroservice.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

@Entity
@Table(name="rooms")
public class Rooms {
	
	 @Id
	    @GeneratedValue(strategy = GenerationType.IDENTITY)
	    private long id;

	    private String roomType;

	    @Column(name = "base_price")
	    private double basePrice;

	    @ManyToOne // first part belongs to entity class and second part belongs to reference class
	    @JoinColumn(name = "property_id")
	    @JsonBackReference
	    private Property property;

		public long getId() {
			return id;
		}

		public String getRoomType() {
			return roomType;
		}

		public double getBasePrice() {
			return basePrice;
		}

		public Property getProperty() {
			return property;
		}

		public void setId(long id) {
			this.id = id;
		}

		public void setRoomType(String roomType) {
			this.roomType = roomType;
		}

		public void setBasePrice(double basePrice) {
			this.basePrice = basePrice;
		}

		public void setProperty(Property property) {
			this.property = property;
		}
}

(g). Create a RoomAvailability entity class 

package com.propertyMicroservice.entity;

import java.time.LocalDate;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

@Entity
@Table(name = "room_availability")
public class RoomAvailability {
	
	@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private LocalDate availableDate;
    private int availableCount;
    private double price;

    @ManyToOne
    @JoinColumn(name = "room_id")
    private Rooms room;

	public long getId() {
		return id;
	}

	public LocalDate getAvailableDate() {
		return availableDate;
	}

	public int getAvailableCount() {
		return availableCount;
	}

	public double getPrice() {
		return price;
	}

	public Rooms getRoom() {
		return room;
	}

	public void setId(long id) {
		this.id = id;
	}

	public void setAvailableDate(LocalDate availableDate) {
		this.availableDate = availableDate;
	}

	public void setAvailableCount(int availableCount) {
		this.availableCount = availableCount;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	public void setRoom(Rooms room) {
		this.room = room;
	}
}

Step 4. Now create repository layer inside repository package of all entity class 

(a). AreaRepository
-------------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.propertyMicroservice.entity.Area;

@Repository
public interface AreaRepository extends JpaRepository<Area, Long> {
	Area findByName(String name);
}

(b). CityRepository
-----------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.propertyMicroservice.entity.City;

@Repository
public interface CityRepository extends JpaRepository<City, Long> {	
	City findByName(String name);
}

(c). PropertyPhotosRepository
-----------------------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import com.propertyMicroservice.entity.PropertyPhotos;

public interface PropertyPhotosRepository extends JpaRepository<PropertyPhotos , Long> {

}

(d). PropertyRepository 
----------------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import com.propertyMicroservice.entity.Property;

public interface PropertyRepository extends JpaRepository<Property, Long>{

}

(e). RoomAvailabilityRepository
------------------------------------------
package com.propertyMicroservice.repository;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.propertyMicroservice.entity.RoomAvailability;

@Repository
public interface RoomAvailabilityRepository extends JpaRepository<RoomAvailability, Long> {	
	public List<RoomAvailability> findByRoomId(long id);

}

(f). RoomRepository
-------------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.propertyMicroservice.entity.Rooms;

@Repository
public interface RoomRepository extends JpaRepository<Rooms, Long> {

}

(g). StateRepository
--------------------------
package com.propertyMicroservice.repository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.propertyMicroservice.entity.State;

@Repository
public interface StateRepository extends JpaRepository<State, Long> {
	State findByName(String name);

}

Step 5 : Now create DTO of following entity class inside dto package 

(a). PropertyDto
--------------------------
package com.propertyMicroservice.dto;

import java.util.List;

public class PropertyDto {
	
	private long id;
	private String name;
	private int numberOfBeds;
	private int numberOfRooms;
	private int numberOfBathrooms;
	private int numberOfGuestAllowed;
	private String city;
	private String area;
	private String state;
	
	private List<RoomsDto> rooms; // list of rooms
	private List<String> imageUrls; // list of images

	public long getId() {
		return id;
	}
	public String getName() {
		return name;
	}
	public int getNumberOfBeds() {
		return numberOfBeds;
	}
	public int getNumberOfRooms() {
		return numberOfRooms;
	}
	public int getNumberOfBathrooms() {
		return numberOfBathrooms;
	}
	public int getNumberOfGuestAllowed() {
		return numberOfGuestAllowed;
	}
	public String getCity() {
		return city;
	}
	public String getArea() {
		return area;
	}
	public String getState() {
		return state;
	}
	public List<RoomsDto> getRooms() {
		return rooms;
	}
	public void setId(long id) {
		this.id = id;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setNumberOfBeds(int numberOfBeds) {
		this.numberOfBeds = numberOfBeds;
	}
	public void setNumberOfRooms(int numberOfRooms) {
		this.numberOfRooms = numberOfRooms;
	}
	public void setNumberOfBathrooms(int numberOfBathrooms) {
		this.numberOfBathrooms = numberOfBathrooms;
	}
	public void setNumberOfGuestAllowed(int numberOfGuestAllowed) {
		this.numberOfGuestAllowed = numberOfGuestAllowed;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public void setArea(String area) {
		this.area = area;
	}
	public void setState(String state) {
		this.state = state;
	}
	public void setRooms(List<RoomsDto> rooms) {
		this.rooms = rooms;
	}
	public List<String> getImageUrls() {
		return imageUrls;
	}
	public void setImageUrls(List<String> imageUrls) {
		this.imageUrls = imageUrls;
	}
}

(b). RoomsDto
---------------------

package com.propertyMicroservice.dto;

public class RoomsDto {
	
    private long id;
	private String roomType;
    private double basePrice;

	public long getId() {
		return id;
	}
	public String getRoomType() {
		return roomType;
	}	
	public void setId(long id) {
		this.id = id;
	}
	public void setRoomType(String roomType) {
		this.roomType = roomType;
	}
	public double getBasePrice() {
		return basePrice;
	}
	public void setBasePrice(double basePrice) {
		this.basePrice = basePrice;
	}
}

(c). APIResponse
-----------------------

package com.propertyMicroservice.dto;

public class APIResponse<T> {
	
	private String message;
	private int status;
	private T data;
 
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public int getStatus() {
		return status;
	}
	public void setStatus(int status) {
		this.status = status;
	}
	public T getData() {
		return data;
	}
	public void setData(T data) {
		this.data = data;
	}
}

Step 6 : Now Create a PropertyController inside controller package 

// ============================
// Add Property
// ============================

package com.propertyMicroservice.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.propertyMicroservice.dto.APIResponse;
import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.service.PropertyService;

@RestController
@RequestMapping("/api/v1/property")
public class PropertyController {

	@Autowired
    private PropertyService propertyService;

@PostMapping(
            value = "/add-property",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<APIResponse> addProperty(
            @RequestParam("property") String propertyJson,
            @RequestParam("files") MultipartFile[] files) {

    ObjectMapper mapper = new ObjectMapper();
        PropertyDto dto =null;

        try {
            dto = mapper.readValue(propertyJson, PropertyDto.class);
        } catch (JsonProcessingException e) {
        	
        	return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        	
        }

      Property property = propertyService.addProperty(dto, files);
        
        APIResponse<Property> response = new APIResponse<>();
        response.setMessage("Property Added");
        response.setStatus(201);
        response.setData(property);
        
        return new ResponseEntity<>(response,HttpStatus.CREATED);
        
        }
    }

STEP 7 : create PropertyService to add property through logic 

package com.propertyMicroservice.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.entity.Area;
import com.propertyMicroservice.entity.City;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.entity.State;
import com.propertyMicroservice.repository.AreaRepository;
import com.propertyMicroservice.repository.CityRepository;
import com.propertyMicroservice.repository.PropertyPhotosRepository;
import com.propertyMicroservice.repository.PropertyRepository;
import com.propertyMicroservice.repository.RoomAvailabilityRepository;
import com.propertyMicroservice.repository.RoomRepository;
import com.propertyMicroservice.repository.StateRepository;


@Service
public class PropertyService {
	  
	@Autowired
    private PropertyRepository propertyRepository;
    @Autowired
    private AreaRepository areaRepository;
    @Autowired
    private CityRepository cityRepository;
    @Autowired
    private StateRepository stateRepository;
    @Autowired
    private RoomRepository roomRepository;
    @Autowired
    private PropertyPhotosRepository propertyPhotosRepository;
    @Autowired
    private RoomAvailabilityRepository availabilityRepository;

    public Property addProperty(PropertyDto dto, MultipartFile[] files) {

       String cityName = dto.getCity();
       City city = cityRepository.findByName(cityName);
       
       String areaName = dto.getArea();
       Area area = areaRepository.findByName(areaName);
       
       String stateName = dto.getState();
       State state = stateRepository.findByName(stateName);
       
        Property property = new Property();
	    property.setName(dto.getName());
	    property.setNumberOfBathrooms(dto.getNumberOfBathrooms());
	    property.setNumberOfBeds(dto.getNumberOfBeds());
	    property.setNumberOfRooms(dto.getNumberOfRooms());
	    property.setNumberOfGuestAllowed(dto.getNumberOfGuestAllowed());
	    property.setArea(area);
	    property.setCity(city);
	    property.setState(state);
	    
	    Property savedProperty = propertyRepository.save(property);

        for (RoomsDto roomsDto : dto.getRooms()) {
            Rooms rooms = new Rooms();
            rooms.setProperty(savedProperty);
            rooms.setRoomType(roomsDto.getRoomType());
            rooms.setBasePrice(roomsDto.getBasePrice());
                  
            roomRepository.save(rooms);
        }
	    
	    return savedProperty;
}

}

STEP 8 : convert into JSON DATA OF Rooms entity class for sending to DB

Q: How to send in postman ?

select form-data and choose body and 

in key :name of property(text) and in value : give json formate data
below property give: files (select file)  and upload fille

{
  "name": "Hotel Sunshine",
  "numberOfBeds": 4,
  "numberOfRooms": 2,
  "numberOfBathrooms": 2,
  "numberOfGuestAllowed": 6,
  "city": "bengaluru",   // MUST AVAILABLE IN DB
  "area": "BTM",         // MUST AVAILABLE IN DB
  "state": "karnatka",    // MUST AVAILABLE IN DB
  "rooms": [
    {
      "roomType": "Deluxe",
      "basePrice": 2500
    },
    {
      "roomType": "Suite",
      "basePrice": 4500
    }
  ]
}

note : click here to send in db Post : http://localhost:9091/api/v1/property/add-property , you will get get details and data saved in db


Step 9 : create a aws account to store the audio, video and photo in s3 service 

(a). create a bucket in s3 service to store the photoes

___________________________________________________________________________________________________________________________

‚úÖ Create S3 Bucket in AWS ‚Äî Step by Step

1Ô∏è‚É£ Login to AWS

Go to
üîó https://aws.amazon.com/console

‚Üí Sign in to your AWS account.

2Ô∏è‚É£ Open S3 Service

Search S3 in the AWS search bar ‚Üí Click Amazon S3.

3Ô∏è‚É£ Create Bucket

Click the orange button:
üëâ Create bucket

4Ô∏è‚É£ Fill Basic Details
Bucket name

Must be globally unique

Use lowercase

No spaces
Example:

my-property-app-bucket

AWS Region

Choose the same region as your Spring Boot config.
Common:

ap-south-1 (Mumbai)

5Ô∏è‚É£ Bucket Settings
Block Public Access (recommended)

Keep ON ‚Äî unless you are hosting public images.

If you want uploaded images to be public, then:

Uncheck "Block all public access"

Confirm the warning.

But recommended is:

Keep private

Use signed URLs.

6Ô∏è‚É£ Bucket Versioning (optional)

If you want old versions of images ‚Üí turn ON.
Otherwise leave OFF.

7Ô∏è‚É£ Encryption

Keep default:

SSE-S3 (server-side encryption).

8Ô∏è‚É£ Click: Create bucket

Done! üéâ
Your bucket is now created.

‚≠ê Next Step for Your Spring Boot App

You need:

Bucket name
my-property-app-bucket

Region
ap-south-1


You will also need:

Access Key + Secret Key

Go to:

AWS Console ‚Üí IAM ‚Üí Users ‚Üí (Your User) ‚Üí Security Credentials ‚Üí Create Access Key

‚Üí Choose Command Line / Programmatic Access
‚Üí Download .csv file.

___________________________________________________________________________________________________________________

(b). After perform the configuration for aws s3 service in application.propertise

     Note : But before performing the work on asw s2 service , Add of below dependency in pom.xml file

       <dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-s3</artifactId>
			<version>1.12.656</version> <!-- Use latest -->
		</dependency>

Then do confiuration : 

application.propertise
-------------------------
# AWS Credentials
cloud.aws.region.static=ap-south-1
cloud.aws.credentials.access-key= aws-access-key
cloud.aws.credentials.secret-key=asw-secret-key

# S3 Bucket Details
aws.s3.bucket.name=my-hms-photos // s3 bucket name 

(c). create AmazonS3Config class inside config package to login the aws account 

AmazonS3Config
------------------
package com.propertyMicroservice.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
 
@Configuration
public class AmazonS3Config {
	
	@Value("${cloud.aws.region.static}")
    private String region;

    @Value("${cloud.aws.credentials.access-key}")
    private String accessKey;

    @Value("${cloud.aws.credentials.secret-key}")
    private String secretKey;

    @Bean
    public AmazonS3 amazonS3() {
        BasicAWSCredentials credentials = new BasicAWSCredentials(accessKey, secretKey);
        return AmazonS3ClientBuilder.standard()
                .withRegion(region)
                .withCredentials(new AWSStaticCredentialsProvider(credentials))
                .build();
    }
}

(d). After create S3Service for 

S3Service.class
-----------------

package com.propertyMicroservice.service;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;

@Service
  public class S3Service {	
	
	@Autowired
    private AmazonS3 amazonS3;

    @Value("${aws.s3.bucket.name}")
    private String bucketName;

    public List<String> uploadFiles(MultipartFile[] files) {
        List<String> urls = new ArrayList<>();
        for (MultipartFile file : files) {
            String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
            try {
                ObjectMetadata metadata = new ObjectMetadata();
                metadata.setContentLength(file.getSize());
                amazonS3.putObject(bucketName, fileName, file.getInputStream(), metadata);
                urls.add(amazonS3.getUrl(bucketName, fileName).toString());
            } catch (IOException e) {
                throw new RuntimeException("Error uploading file to S3", e);
            }
        }
        return urls;
    } 
  }
 
(e). Now modify the PropertyService to store the photos in s3 service 

PropertyService.class
------------------------
package com.propertyMicroservice.service;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.dto.RoomsDto;
import com.propertyMicroservice.entity.Area;
import com.propertyMicroservice.entity.City;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.entity.PropertyPhotos;
import com.propertyMicroservice.entity.Rooms;
import com.propertyMicroservice.entity.State;
import com.propertyMicroservice.repository.AreaRepository;
import com.propertyMicroservice.repository.CityRepository;
import com.propertyMicroservice.repository.PropertyPhotosRepository;
import com.propertyMicroservice.repository.PropertyRepository;
import com.propertyMicroservice.repository.RoomAvailabilityRepository;
import com.propertyMicroservice.repository.RoomRepository;
import com.propertyMicroservice.repository.StateRepository;


@Service
public class PropertyService {
	  
	@Autowired
    private PropertyRepository propertyRepository;
    @Autowired
    private AreaRepository areaRepository;
    @Autowired
    private CityRepository cityRepository;
    @Autowired
    private StateRepository stateRepository;
    @Autowired
    private RoomRepository roomRepository;
    @Autowired
    private PropertyPhotosRepository propertyPhotosRepository;
    @Autowired
    private RoomAvailabilityRepository availabilityRepository;

    @Autowired // modified for s3
    private S3Service s3Service;

    public Property addProperty(PropertyDto dto, MultipartFile[] files) {

       String cityName = dto.getCity();
       City city = cityRepository.findByName(cityName);
       
       String areaName = dto.getArea();
       Area area = areaRepository.findByName(areaName);
       
       String stateName = dto.getState();
       State state = stateRepository.findByName(stateName);
       
       Property property = new Property();
	    property.setName(dto.getName());
	    property.setNumberOfBathrooms(dto.getNumberOfBathrooms());
	    property.setNumberOfBeds(dto.getNumberOfBeds());
	    property.setNumberOfRooms(dto.getNumberOfRooms());
	    property.setNumberOfGuestAllowed(dto.getNumberOfGuestAllowed());
	    property.setArea(area);
	    property.setCity(city);
	    property.setState(state);
	    
	    Property savedProperty = propertyRepository.save(property);     

        for (RoomsDto roomsDto : dto.getRooms()) {
            Rooms rooms = new Rooms();
            rooms.setProperty(savedProperty);
            rooms.setRoomType(roomsDto.getRoomType());
            rooms.setBasePrice(roomsDto.getBasePrice());
                  
            roomRepository.save(rooms);
        }     

     // upload files to s3 (modified) 

        List<String> fileUrls = s3Service.uploadFiles(files);

        for (String url :fileUrls) {
            PropertyPhotos photo = new PropertyPhotos();
            photo.setUrl(url);
            photo.setProperty(savedProperty);
            propertyPhotosRepository.save(photo);
        }
   
        return savedProperty;
    }
}

Note : Post : http://localhost:9091/api/v1/property/add-property , Now go to postman and select body give key , json formate data and choose file and upload photo

3Ô∏è‚É£ Quick fix for Postman

Set Body ‚Üí form-data

Key: property, Type: Text and Value: Paste your full JSON (no extra quotes, no line breaks issues)

Key: files, Type: File ‚Üí choose your images

This almost always solves the "Invalid property JSON format" issue.

{
  "name": "Hotel Sunshine",
  "numberOfBeds": 4,
  "numberOfRooms": 2,
  "numberOfBathrooms": 2,
  "numberOfGuestAllowed": 6,
  "city": "bengaluru",       
  "area": "BTM",
  "state": "karnatka",
  "rooms": [
    {
      "roomType": "Deluxe",
      "basePrice": 2500
    },
    {
      "roomType": "Suite",
      "basePrice": 4500
    }
  ]
}

now go to db and s3 service , you will get photo .

Step 10 : Now work on sms integration using kafka , for this add kafka dependency in pom.xml file 

(a) : pom.xml
-----------------------
<!-- Kafka -->
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
	    </dependency>

(b) perform configuration for kafka for sms integration 

application.propertise
------------------------------
spring.application.name=property-microservice-3

server.port = 9091
# ================================
# DATABASE CONFIGURATION
# ================================
spring.datasource.url=jdbc:mysql://localhost:3306/propertyservicedb
spring.datasource.username=root
spring.datasource.password=
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ================================
# JPA / HIBERNATE CONFIGURATION
# ================================
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect


# AWS Credentials
cloud.aws.region.static=ap-south-1
cloud.aws.credentials.access-key=
cloud.aws.credentials.secret-key=

# S3 Bucket Details
aws.s3.bucket.name=my-hms-photos

# kafka 
spring.kafka.bootstrap-servers=ec2-35-154-211-81.ap-south-1.compute.amazonaws.com:9092 // DNS URL FROM AWS EC2


(c) After modify the propertiseService

package com.propertyMicroservice.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.propertyMicroservice.constants.AppConstants;
import com.propertyMicroservice.dto.EmailRequest;
import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.dto.RoomsDto;
import com.propertyMicroservice.entity.Area;
import com.propertyMicroservice.entity.City;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.entity.PropertyPhotos;
import com.propertyMicroservice.entity.Rooms;
import com.propertyMicroservice.entity.State;
import com.propertyMicroservice.repository.AreaRepository;
import com.propertyMicroservice.repository.CityRepository;
import com.propertyMicroservice.repository.PropertyPhotosRepository;
import com.propertyMicroservice.repository.PropertyRepository;
import com.propertyMicroservice.repository.RoomAvailabilityRepository;
import com.propertyMicroservice.repository.RoomRepository;
import com.propertyMicroservice.repository.StateRepository;


@Service
public class PropertyService {
	  
	@Autowired
    private PropertyRepository propertyRepository;
    @Autowired
    private AreaRepository areaRepository;
    @Autowired
    private CityRepository cityRepository;
    @Autowired
    private StateRepository stateRepository;
    @Autowired
    private RoomRepository roomRepository;
    @Autowired
    private PropertyPhotosRepository propertyPhotosRepository;
    @Autowired
    private RoomAvailabilityRepository availabilityRepository;
    @Autowired
    private S3Service s3Service;
    
    @Autowired
	private KafkaTemplate<String, EmailRequest> kafkaTemplate;
    
	

    public Property addProperty(PropertyDto dto, MultipartFile[] files) {

       String cityName = dto.getCity();
       City city = cityRepository.findByName(cityName);
       
       String areaName = dto.getArea();
       Area area = areaRepository.findByName(areaName);
       
       String stateName = dto.getState();
       State state = stateRepository.findByName(stateName);
       
       Property property = new Property();
	    property.setName(dto.getName());
	    property.setNumberOfBathrooms(dto.getNumberOfBathrooms());
	    property.setNumberOfBeds(dto.getNumberOfBeds());
	    property.setNumberOfRooms(dto.getNumberOfRooms());
	    property.setNumberOfGuestAllowed(dto.getNumberOfGuestAllowed());
	    property.setArea(area);
	    property.setCity(city);
	    property.setState(state);
	    
	    Property savedProperty = propertyRepository.save(property);
	    
       

        for (RoomsDto roomsDto : dto.getRooms()) {
            Rooms rooms = new Rooms();
            rooms.setProperty(savedProperty);
            rooms.setRoomType(roomsDto.getRoomType());
            rooms.setBasePrice(roomsDto.getBasePrice());
                  
            roomRepository.save(rooms);
        }
        
     // sends msg to kafka topic
        
        EmailRequest emailRequest = new EmailRequest("ajaysahni854301@gmail.com","Property Added","Your property details are not live");
     		kafkaTemplate.send(AppConstants.TOPIC, emailRequest);
        
       

     // upload files to s3  
        List<String> fileUrls = s3Service.uploadFiles(files);

        for (String url :fileUrls) {
            PropertyPhotos photo = new PropertyPhotos();
            photo.setUrl(url);
            photo.setProperty(savedProperty);
            propertyPhotosRepository.save(photo);
        }

     
        return savedProperty;
    }

(d) Now create EmailRequest class inside DTO (propertise-service project)

package com.propertyMicroservice.dto;

public class EmailRequest {
	
	// This complete data go to broker
	
	private String to;
    private String subject;
    private String body;
    
    
    
	public EmailRequest(String to, String subject, String body) {
		this.to = to;
		this.subject = subject;
		this.body = body;
	}
	public String getTo() {
		return to;
	}
	public String getSubject() {
		return subject;
	}
	public String getBody() {
		return body;
	}
	public void setTo(String to) {
		this.to = to;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public void setBody(String body) {
		this.body = body;
	}
	
	@Override
	public String toString() {
		return "EmailRequest [to=" + to + ", subject=" + subject + ", body=" + body + "]";
	}

}

(e). Now create a AppConstant class inside constant package 

package com.propertyMicroservice.constants;

public class AppConstants {
	
	public static final String TOPIC = "send_email";
	public static final String KAFKA_HOST = "ec2-35-154-211-81.ap-south-1.compute.amazonaws.com:9092"; // DNS URL from ec2 

}

(f). Now create KafkaProduceConfiguration inside config package in property-service project 

package com.propertyMicroservice.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.support.serializer.JsonSerializer;

import com.propertyMicroservice.constants.AppConstants;
import com.propertyMicroservice.dto.EmailRequest;

@Configuration
public class KafkaProduceConfiguration {
	
	@Bean
	public ProducerFactory<String, EmailRequest> producerFactory() {

		Map<String, Object> kafkaProps = new HashMap<>();

		kafkaProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, AppConstants.KAFKA_HOST);
		kafkaProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
		kafkaProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);

		return new DefaultKafkaProducerFactory<>(kafkaProps);
	}

	@Bean
	public KafkaTemplate<String, EmailRequest> kafkaTemplate() {
		return new KafkaTemplate<>(producerFactory());
	}

}


====================================================================================================================================
-----------------------
Create a new project(notification-service) for email sms integration 
---------------------
(a) Create a new project and add these dependency :
(1). spring web

(2). Java Mail Sender

(3) kafka 
<!-- Kafka -->
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
	    </dependency>

(b) setup the configuration in application.propertise file 

# App
spring.application.name=notification-service
server.port=9094

# MAIL CONFIG
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=ajaysahni@gmail.com
spring.mail.password=iofa wisb rpvq nyfm
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# kafka 
spring.kafka.bootstrap-servers=ec2-35-154-211-81.ap-south-1.compute.amazonaws.com:9092

(c) now create AppConstants class inside (appconstant package) 

AppConstants
-----------------
package com.notificationService.appconstants;

public class AppConstants {
	
	public static final String TOPIC = "send_email";
	public static final String KAFKA_HOST = "ec2-35-154-211-81.ap-south-1.compute.amazonaws.com:9092";

}


(d) Now crate a KafkaConsumerConfig class inside config package (notification-service project )

KafkaConsumerConfig
----------------------

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.support.serializer.JsonDeserializer;

import com.notificationService.appconstants.AppConstants;
import com.notificationService.dto.EmailRequest;

@Configuration
public class KafkaConsumerConfig {
	
	@Bean
	public ConsumerFactory<String, EmailRequest> consumerFactory() {

		Map<String, Object> kafkaConfigProps = new HashMap<String, Object>();

		kafkaConfigProps .put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, AppConstants.KAFKA_HOST);
		kafkaConfigProps .put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
		kafkaConfigProps .put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);

		return new DefaultKafkaConsumerFactory<>(kafkaConfigProps, new StringDeserializer(), new JsonDeserializer<>());

	}

	@Bean
	public ConcurrentKafkaListenerContainerFactory<String, EmailRequest> kafkaListnerFactory() {

		ConcurrentKafkaListenerContainerFactory<String, EmailRequest> factory = 
				new ConcurrentKafkaListenerContainerFactory<>();

		factory.setConsumerFactory(consumerFactory());

		return factory;
	}

}


(e) now create EmailRequestListner inside service package

EmailRequestListner
--------------------------

package com.notificationService.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.notificationService.appconstants.AppConstants;
import com.notificationService.dto.EmailRequest;

@Service
public class EmailRequestListner { 
	
	@Autowired
	private JavaMailSender javaMailSender;
    
    private final ObjectMapper objectMapper = new ObjectMapper();

    @KafkaListener(topics = AppConstants.TOPIC, groupId = "group_email")
    public void kafkaSubscriberContent(String emailRequest) {
        try {
            EmailRequest emailContent = objectMapper.readValue(emailRequest, EmailRequest.class);
            SimpleMailMessage sm = new SimpleMailMessage();
            sm.setTo(emailContent.getTo());
            sm.setSubject(emailContent.getSubject());
            sm.setText(emailContent.getBody());
            javaMailSender.send(sm);
            

        } catch (JsonMappingException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


(f). Now create EmailRequest class inside DTO package

EmailRequest
--------------
package com.notificationService.dto;

public class EmailRequest {
	
	 private String to;
	 private String subject;
	    
	 private String body;
	    	    
		public EmailRequest(String to, String subject, String body) {
			this.to = to;
			this.subject = subject;
			this.body = body;
		}
		public String getTo() {
			return to;
		}
		public String getSubject() {
			return subject;
		}
		public String getBody() {
			return body;
		}
		public void setTo(String to) {
			this.to = to;
		}
		public void setSubject(String subject) {
			this.subject = subject;
		}
		public void setBody(String body) {
			this.body = body;
		}
}

now access through this link in postman form-data : http://localhost:9091/api/v1/property/add-property

Note : 
now open gmail and click on manage emial and go to security option and type two step verification and Enable two step verification 
in gmail and after that search App password in search box and click on that and give App name whichever you want and click on create ,
after you will get one password , copy the password and past in application.propertise file of notification-service project for email notification.

application.propertise in notification-service project 
----------------------------
spring.application.name=notification-service

server.port=9093

spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=ajaysahni854301@gmail.com
spring.mail.password=iofa wisb rpvq nyfm  // App password 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

=========================================================================================================================================

________________________________________________________________________________________________________________________________________
                         Now perform Search operation using @query annotation in spring data jpa :
-----------------------------------------------------------------------------------------------------------------------------------------

 Step 1 : modify propertyRepository build search query based on entities class 

PropertyRepository
---------------------

package com.propertyMicroservice.repository;

import java.time.LocalDate;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import com.propertyMicroservice.entity.Property;

public interface PropertyRepository extends JpaRepository<Property, Long>{
	
	
	@Query("""
		    SELECT DISTINCT p
		    FROM Property p
		    JOIN p.rooms r
		    JOIN RoomAvailability ra ON ra.room = r
		    WHERE (
		        LOWER(p.city.name) LIKE LOWER(CONCAT('%', :name, '%')) OR
		        LOWER(p.area.name) LIKE LOWER(CONCAT('%', :name, '%')) OR
		        LOWER(p.state.name) LIKE LOWER(CONCAT('%', :name, '%'))
		    )
		    AND ra.availableDate = :date
		    AND ra.availableCount > 0
		""")
		List<Property> searchProperty(
		        @Param("name") String name,
		        @Param("date") LocalDate date
		);	
}


step 2: modify the PropertyService for search operation 

package com.propertyMicroservice.service;
import java.time.LocalDate;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import com.propertyMicroservice.constants.AppConstants;
import com.propertyMicroservice.dto.APIResponse;
import com.propertyMicroservice.dto.EmailRequest;
import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.dto.RoomsDto;
import com.propertyMicroservice.entity.Area;
import com.propertyMicroservice.entity.City;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.entity.PropertyPhotos;
import com.propertyMicroservice.entity.Rooms;
import com.propertyMicroservice.entity.State;
import com.propertyMicroservice.repository.AreaRepository;
import com.propertyMicroservice.repository.CityRepository;
import com.propertyMicroservice.repository.PropertyPhotosRepository;
import com.propertyMicroservice.repository.PropertyRepository;
import com.propertyMicroservice.repository.RoomAvailabilityRepository;
import com.propertyMicroservice.repository.RoomRepository;
import com.propertyMicroservice.repository.StateRepository;


@Service
public class PropertyService {
	  
	@Autowired
    private PropertyRepository propertyRepository;
    @Autowired
    private AreaRepository areaRepository;
    @Autowired
    private CityRepository cityRepository;
    @Autowired
    private StateRepository stateRepository;
    @Autowired
    private RoomRepository roomRepository;
    @Autowired
    private PropertyPhotosRepository propertyPhotosRepository;
    @Autowired
    private RoomAvailabilityRepository availabilityRepository;
    @Autowired
    private S3Service s3Service;
    
    @Autowired
	private KafkaTemplate<String, EmailRequest> kafkaTemplate;
    
	

    public Property addProperty(PropertyDto dto, MultipartFile[] files) {

       String cityName = dto.getCity();
       City city = cityRepository.findByName(cityName);
       
       String areaName = dto.getArea();
       Area area = areaRepository.findByName(areaName);
       
       String stateName = dto.getState();
       State state = stateRepository.findByName(stateName);
       
       Property property = new Property();
	    property.setName(dto.getName());
	    property.setNumberOfBathrooms(dto.getNumberOfBathrooms());
	    property.setNumberOfBeds(dto.getNumberOfBeds());
	    property.setNumberOfRooms(dto.getNumberOfRooms());
	    property.setNumberOfGuestAllowed(dto.getNumberOfGuestAllowed());
	    property.setArea(area);
	    property.setCity(city);
	    property.setState(state);
	    
	    Property savedProperty = propertyRepository.save(property);
	    
       

        for (RoomsDto roomsDto : dto.getRooms()) {
            Rooms rooms = new Rooms();
            rooms.setProperty(savedProperty);
            rooms.setRoomType(roomsDto.getRoomType());
            rooms.setBasePrice(roomsDto.getBasePrice());
                  
            roomRepository.save(rooms);
        }
        
     // sends msg to kafka topic
        
        EmailRequest emailRequest = new EmailRequest("ajaysahni854302@gmail.com","Property Added","Your property details are not live");
     		kafkaTemplate.send(AppConstants.TOPIC, emailRequest);
          

			
			  // upload files to s3 
     		
     		List<String> fileUrls = s3Service.uploadFiles(files);
			  
			  for (String url :fileUrls) {
				  PropertyPhotos photo = new PropertyPhotos();
			      photo.setUrl(url); 
			      photo.setProperty(savedProperty);
			      propertyPhotosRepository.save(photo); 
			  }
			 
     
        return savedProperty;
    }

    // Search property 

    public APIResponse searchProperty(String city, LocalDate date) {
		List<Property> properties = propertyRepository.searchProperty(city,date);
		APIResponse<List<Property>> response = new APIResponse<>();
		
		response.setMessage("Search result");
		response.setStatus(200);
		response.setData(properties);
		
		return response;
	}

step 3: modify the PropertyController for search operation 

package com.propertyMicroservice.controller;

import java.time.LocalDate;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.propertyMicroservice.dto.APIResponse;
import com.propertyMicroservice.dto.PropertyDto;
import com.propertyMicroservice.entity.Property;
import com.propertyMicroservice.service.PropertyService;

@RestController
@RequestMapping("/api/v1/property")
public class PropertyController {

	@Autowired
    private PropertyService propertyService;

// ============================
    // Add Property with Images
    // ============================
    @PostMapping(
            value = "/add-property",
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public ResponseEntity<APIResponse> addProperty(
            @RequestParam("property") String propertyJson,
            @RequestParam("files") MultipartFile[] files) {

    ObjectMapper mapper = new ObjectMapper();
        PropertyDto dto =null;

        try {
            dto = mapper.readValue(propertyJson, PropertyDto.class);
        } catch (JsonProcessingException e) {
        	
        	return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        	
        }


       Property property = propertyService.addProperty(dto, files);
        
        APIResponse<Property> response = new APIResponse<>();
        response.setMessage("Property Added");
        response.setStatus(201);
        response.setData(property);
        
        return new ResponseEntity<>(response,HttpStatus.CREATED);
        
        
    }

    // ============================
    // Search Property
    // ============================
	
	  @GetMapping("/search-property")
	  
	  public APIResponse searchProperty(
	  
	  @RequestParam String name,
	  
	  @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date
	  
	  ) {
	  
	  APIResponse response = propertyService.searchProperty(name, date);
	  
	  return response;
	  
	  }

Note : 

make sure your databse should have these details before searching : 

1Ô∏è‚É£ Insert State
INSERT INTO state (name) VALUES ('Tamil Nadu');

2Ô∏è‚É£ Insert City
INSERT INTO city (name) VALUES ('Chennai');

3Ô∏è‚É£ Insert Area
INSERT INTO area (name) VALUES ('Adyar');

4Ô∏è‚É£ Insert Property
INSERT INTO property (name, number_of_beds, number_of_rooms, number_of_bathrooms, number_of_guests_allowed, city_id, area_id, state_id)
VALUES ('Seaside Villa', 3, 2, 2, 6, 1, 1, 1);


Assumes city_id = 1, area_id = 1, state_id = 1.

5Ô∏è‚É£ Insert Rooms for Property
INSERT INTO rooms (room_type, base_price, property_id)
VALUES 
('Deluxe', 3000.0, 1),
('Standard', 2000.0, 1);

6Ô∏è‚É£ Insert RoomAvailability
INSERT INTO room_availability (available_date, available_count, price, room_id)
VALUES
('2025-12-14', 2, 3000.0, 1),
('2025-12-14', 3, 2000.0, 2);

‚úÖ Now your database has:

1 State ‚Üí Tamil Nadu

1 City ‚Üí Chennai

1 Area ‚Üí Adyar

1 Property ‚Üí Seaside Villa

2 Rooms ‚Üí Deluxe, Standard

RoomAvailability for 2025-12-14

This should make your GET http://localhost:9091/api/v1/property/search-property?name=chennai&date=2025-12-14 return actual data.

=======================================================================================================================================

