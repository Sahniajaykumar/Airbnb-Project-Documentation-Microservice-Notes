Q: How do you convert AuthServce project(monolithic) into distributed microservice architecture ?
--------------------------------------------------------------------------------------------------------

Step 1 : For that add Eureka client(ensure that you already created Eureka Server) inside authservice to register this project with Eureka server

<dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${spring-cloud.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>

Step 2 : Enable @EnableDiscoveryClient in main class of authservice class to register with Eureka server
--------------------------------------------------------------------------------------------------------------

Step 3 : Now put this in authservice propertise class for good practice 
---------------------------------------------------------------------------------------------------------------

#Eureka - Optional if you are running eureka on port 8671
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

---------------------------------------------------------------------------------------------------------------
Create API Gateway project for JWL Filterization : add routing  in YML file 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1. First remove JWTFilter class from configuration file and modify security filter chain because i am not filtering JWT in config file 
2. I will filter the jwt token in API Gateway class 
 // ====================================
 // 3. Security Filter Chain Configuration
 // ====================================
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http.csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> {
                auth.requestMatchers(OPEN_URLS).permitAll()
                    .anyRequest().permitAll(); // AuthService doesn’t validate JWT now
            });

        return http.build();
    }
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Step 1: Inject this JWT library dependency in pom.xml file 
--------------------------------------------------------------------
   <dependency>
		    <groupId>com.auth0</groupId>
		    <artifactId>java-jwt</artifactId>
		    <version>4.4.0</version> <!-- or the latest stable version -->
		</dependency>

Step 2 : Create JwtAuthenticationFilter class inside Gateway project for Token validation at Gateway : 
Use a Gateway GlobalFilter (or a custom GatewayFilterFactory) that runs before the request is routed.
In Spring Cloud Gateway (WebFlux) the filter will be reactive.

Created JwtAuthenticationFilter class : 
-----------------------------------------
package com.apigateway.filter;

import java.util.List;
import java.util.Map;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;

import reactor.core.publisher.Mono;

@Component // which ever URL will come with token first come to this class for verification
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {
	
	 private static final String SECRET_KEY = "my-super-secret-key"; // should match signature

	    private static final List<String> openApiEndpoints = List.of( // open URL
	            "/auth/api/v1/auth/login",
	            "/auth/api/v1/auth/register"
	    );

	    private static final Map<String, List<String>> protectedEndpointsWithRoles = Map.of(
	    	    "/auth/api/v1/welcome/message", List.of("ROLE_ADMIN") // protected URL/auth written from YML file
	    	);


	    @Override
	    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
	        String requestPath = exchange.getRequest().getURI().getPath();

	        // Allow public ENDPOINTS 
	        if (isPublicEndpoint(requestPath)) {
	            return chain.filter(exchange);
	        }

	        String authHeader = exchange.getRequest().getHeaders().getFirst("Authorization");
	        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        String token = authHeader.substring(7);

	        try {
	            DecodedJWT jwt = JWT.require(Algorithm.HMAC256(SECRET_KEY))
	                    .build()
	                    .verify(token);

	            String role = jwt.getClaim("role").asString();

	            System.out.println("Request path: " + requestPath);
	            System.out.println("Role from token: " + role);

	            if (!isAuthorized(requestPath, role)) {
	                exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
	                return exchange.getResponse().setComplete();
	            }

	            // Pass role to downstream services (optional)
	            exchange = exchange.mutate()
	                    .request(r -> r.header("X-User-Role", role))
	                    .build();

	        } catch (JWTVerificationException e) {
	            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
	            return exchange.getResponse().setComplete();
	        }

	        return chain.filter(exchange);
	    }

	    private boolean isPublicEndpoint(String path) {
	        return openApiEndpoints.stream().anyMatch(path::equalsIgnoreCase);
	    }

	    private boolean isAuthorized(String path, String role) {
	        for (Map.Entry<String, List<String>> entry : protectedEndpointsWithRoles.entrySet()) {
	            String protectedPath = entry.getKey();
	            List<String> allowedRoles = entry.getValue();

	            if (path.startsWith(protectedPath)) {
	                System.out.println("Matched protected path: " + protectedPath + " | Allowed roles: " + allowedRoles);
	                return allowedRoles.contains(role);
	            }
	        }
	        return true; // Allow access if path is not protected (can be changed to false to deny by default)
	    }

	    @Override
	    public int getOrder() {
	        return -1;
	    }
	}

Step 4: Add Routes in yml file 
-----------------------------------
server:
  port: 5555
  
spring:
  application:
    name: api-gateway-1

  cloud:
    gateway:
      routes:

        # Route for microservice-1
        - id: authservice-api-1
          uri: lb://AUTH-SERVICE
          predicates:
            - Path=/auth/**
          filters:
            - RewritePath=/auth/(?<segment>.*), /${segment}

        # Route for microservice-2 // this is for next microservice 
        - id: microservice-api-2
          uri: lb://MICROSERVICE-2
          predicates:
            - Path=/micro2/**
          filters:
            - RewritePath=/micro2/(?<segment>.*), /${segment}


Step 5 : Now perform registration and login operation :

(a) register :POST : http://localhost:5555/auth/api/v1/auth/register
 {
    "username":"amresh",
    "name":"amresh",
    "email":"amresh@gmail.com",
    "password":"Ajay@123"
}
_________________________________________________
{
    "message": "Registration Successful",
    "status": 201,
    "data": "User registered successfully"
}

(b) login : POST : http://localhost:5555/auth/api/v1/auth/login , you will get JWT token after copy and

past in authorization header to access protected URL : GET : http://localhost:8083/api/v1/welcome/message , you will get welcome ajay

Q: How do you secure a microservices project (very important)?
---------------------------------------------------------------

Step 1 : Create an AuthService using Spring Security and JWT Toekn.
--> AuthService handles user registration, login, and JWT token generation.

Step 2 : When a user logs in, AuthService validates credentials and generates a signed JWT token (with subject, roles, expiry, etc.)

Step 3 : On every request, the API Gateway verify the token (which is the common entry point) 
using JwtAuthenticationFilter which implements GlobalFilter in Spring Cloud Gateway.

step 4 : Inside the Filter method verify the token 

Step 5 : Backend microservices should also verify the token or trust signed user headers → defense-in-depth security.

===============================================================================================================

Next Microservice-2 Project :

Step 1 : create Microservice-2 project using following these dependency : 

1. Spring Web
2. Spring Security
3. Eureka Discovery Client
4. OpenFeign Client
5. DevTools
6. <!-- Auth0 JWT -->
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>java-jwt</artifactId>
        <version>4.4.0</version>
    </dependency>

Step 2: Enable @EnableDiscoveryClient in main class of Microservice-2 project

Step 3 : After create WelcomeControllerApi for testing api inside controller pacage 

package com.microservice2.controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WelcomeControllerApi {
	
	@GetMapping("/message")
	public String getMessage() {
		return "welcome ajay bhai from microservice-2";
	}
}



























